package core

import (
	"bytes"
	"crypto/sha256"
	"encoding/gob"
	"fmt"
	"time"
)

// TransactionType defines the type of transaction.
type TransactionType int

const (
	IntraShard           TransactionType = iota // Transaction within the same shard
	CrossShardTxInit                            // Transaction initiating a cross-shard transfer (source shard)
	CrossShardTxFinalize                        // Transaction finalizing a cross-shard transfer (destination shard)
)

// Transaction represents a standard transaction in the blockchain.
type Transaction struct {
	ID        []byte
	Timestamp int64
	Data      []byte // Payload of the transaction

	// Sharding related fields
	Type               TransactionType
	SourceShard        *uint64       // Optional: Relevant for CrossShardApply
	DestinationShard   *uint64       // Optional: Relevant for CrossShardInitiate
	SourceReceiptProof *ReceiptProof // Optional: Proof carried by CrossShardApply TX
	Nonce              uint64        // Anti-replay for cross-shard or accounts

	// Basic Signature (placeholder - replace with actual crypto/ecdsa)
	PublicKey []byte
	Signature []byte

	// --- Ticket 5: Conflict Resolution ---
	VectorClock VectorClock // Tracks causal dependencies (Uses VectorClock from types.go)
}

// CrossShardReceipt is generated by the source shard when a cross-shard transaction is included in a block.
// It serves as proof for the destination shard.
type CrossShardReceipt struct {
	SourceShard       uint64
	DestinationShard  uint64
	TransactionID     []byte        // ID of the original CrossShardInitiate TX
	SourceBlockHash   []byte        // Hash of the block containing the TX in the source shard
	SourceBlockHeight uint64        // Height of the block containing the TX
	Proof             *ReceiptProof // Proof of inclusion for the transaction in the source block
	// Add other relevant data like amount, target address etc. if needed
	Data []byte // Data from original transaction relevant for destination shard
}

// ReceiptProof contains the necessary information to verify a transaction's inclusion in a block.
// Currently uses Merkle Proof. Could be adapted for SMTs/Accumulators.
type ReceiptProof struct {
	MerkleProof [][]byte // Simplified: just include the hashes needed for verification
	// Could add StateProof here if using SMTs for state changes
}

// NewTransaction creates a new transaction.
// Adapt parameters as needed (e.g., add value, recipient, proper signing).
func NewTransaction(data []byte, txType TransactionType, destShard *uint64) *Transaction {
	tx := &Transaction{
		Timestamp:        time.Now().UnixNano(),
		Data:             data,
		Type:             txType,
		DestinationShard: destShard,
		// Add other fields like Nonce, PublicKey initialization
		// --- Ticket 5: Conflict Resolution ---
		VectorClock: make(VectorClock), // Initialize VectorClock (shardID -> uint64)
	}
	tx.ID = tx.calculateHash() // Set ID based on content
	return tx
}

// calculateHash generates the hash of the transaction (used as its ID).
// Ensure all relevant fields are included for hashing.
func (tx *Transaction) calculateHash() []byte {
	// Exclude ID and Signature from hash calculation itself
	txCopy := *tx
	txCopy.ID = nil
	txCopy.Signature = nil
	txCopy.SourceReceiptProof = nil // Proofs are generated later

	var buf bytes.Buffer
	// Use gob encoding for simplicity, consider more deterministic methods like protobuf
	encoder := gob.NewEncoder(&buf)
	err := encoder.Encode(txCopy)
	if err != nil {
		// In real code, handle this error properly
		panic(fmt.Sprintf("Failed to encode transaction for hashing: %v", err))
	}

	hash := sha256.Sum256(buf.Bytes())
	return hash[:]
}

// Sign calculates the signature of the transaction.
// Placeholder: Replace with actual cryptographic signing (e.g., ecdsa.Sign).
func (tx *Transaction) Sign(privateKey []byte) error {
	// 1. Get the hash of the transaction (excluding signature)
	txHash := tx.calculateHash() // Ensure this doesn't include the signature field

	// 2. Sign the hash
	// signature := sign_with_private_key(privateKey, txHash) // Placeholder
	signature := []byte("placeholder-signature-for-" + string(txHash[:8])) // Dummy signature

	tx.Signature = signature
	// tx.PublicKey = derive_public_key(privateKey) // Placeholder
	tx.PublicKey = []byte("placeholder-pubkey")

	return nil
}

// VerifySignature checks if the transaction signature is valid.
// Placeholder: Replace with actual cryptographic verification (e.g., ecdsa.Verify).
func (tx *Transaction) VerifySignature() bool {
	if tx.PublicKey == nil || tx.Signature == nil {
		return false
	}
	// 1. Get the hash of the transaction (excluding signature)
	txHash := tx.calculateHash() // Ensure this matches the signing hash

	// 2. Verify the signature against the hash and public key
	// isValid := verify_signature(tx.PublicKey, txHash, tx.Signature) // Placeholder
	expectedSignature := []byte("placeholder-signature-for-" + string(txHash[:8]))
	isValid := bytes.Equal(tx.Signature, expectedSignature) // Dummy verification

	return isValid
}

// Hash returns the pre-calculated transaction ID.
func (tx *Transaction) Hash() []byte {
	if tx.ID == nil {
		tx.ID = tx.calculateHash()
	}
	return tx.ID
}

// Serialize encodes the transaction into bytes.
func (tx *Transaction) Serialize() ([]byte, error) {
	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)
	err := encoder.Encode(tx)
	if err != nil {
		return nil, fmt.Errorf("failed to serialize transaction: %w", err)
	}
	return buf.Bytes(), nil
}

// DeserializeTransaction decodes bytes into a transaction.
func DeserializeTransaction(data []byte) (*Transaction, error) {
	var tx Transaction
	decoder := gob.NewDecoder(bytes.NewReader(data))
	err := decoder.Decode(&tx)
	if err != nil {
		return nil, fmt.Errorf("failed to deserialize transaction: %w", err)
	}
	// Re-calculate ID on deserialize? Or trust serialized ID? Trust for now.
	// If ID wasn't serialized, calculate it: tx.ID = tx.calculateHash()
	return &tx, nil
}

// SerializeReceipt encodes the receipt into bytes.
func (r *CrossShardReceipt) Serialize() ([]byte, error) {
	var buf bytes.Buffer
	encoder := gob.NewEncoder(&buf)
	err := encoder.Encode(r)
	if err != nil {
		return nil, fmt.Errorf("failed to serialize receipt: %w", err)
	}
	return buf.Bytes(), nil
}

// DeserializeReceipt decodes bytes into a receipt.
func DeserializeReceipt(data []byte) (*CrossShardReceipt, error) {
	var r CrossShardReceipt
	decoder := gob.NewDecoder(bytes.NewReader(data))
	err := decoder.Decode(&r)
	if err != nil {
		return nil, fmt.Errorf("failed to deserialize receipt: %w", err)
	}
	return &r, nil
}

// GetTransactionIDs returns a slice of transaction IDs from a slice of transactions.
func GetTransactionIDs(transactions []*Transaction) [][]byte {
	var txIDs [][]byte
	for _, tx := range transactions {
		txIDs = append(txIDs, tx.ID)
	}
	return txIDs
}

// NewCrossShardInitTransaction creates a new cross-shard transaction.
func NewCrossShardInitTransaction(data []byte, sourceShard, destShard uint64) *Transaction {
	tx := NewTransaction(data, CrossShardTxInit, &destShard)
	tx.SourceShard = &sourceShard
	return tx
}
